---
# Main tasks for tileserver role - implemented in later todos

- name: Extend sudo timeout to prevent password re-prompts
  lineinfile:
    path: /etc/sudoers.d/ansible-timeout
    line: 'Defaults timestamp_timeout=30'
    create: yes
    mode: '0440'
    validate: 'visudo -cf %s'

- name: Update apt cache (Debian/Ubuntu)
  apt:
    update_cache: yes
    cache_valid_time: 3600
  when: ansible_pkg_mgr == 'apt'

- name: Compute RAM disk size (1/3 of total RAM)
  shell: echo $(( $(free -m | awk 'NR==2{print $2}') / 3 ))
  register: ramdisk_calc
  changed_when: false

- name: Set ramdisk_size_mb fact
  set_fact:
    ramdisk_size_mb: "{{ ramdisk_calc.stdout | trim | int }}"

- name: Format ramdisk_size string (G or M)
  set_fact:
    ramdisk_size: "{{ ((ramdisk_size_mb | int) >= 1024) | ternary((((ramdisk_size_mb | int) // 1024) | int) ~ 'G', (ramdisk_size_mb | int) ~ 'M') }}"

- name: Validate tileserver deployment method
  assert:
    that:
      - tileserver_deploy_method in ['docker', 'native']
    fail_msg: "tileserver_deploy_method must be either 'docker' or 'native'"

- name: Install base runtime dependencies
  package:
    name:
      - rsync
      - python3
    state: present
  become: true

- name: Install native runtime libraries and shims
  block:
    - name: Install native runtime libraries
      package:
        name:
          - libjpeg62-turbo
          - libwebp6
        state: present
      become: true

    - name: Check for libjpeg.so.62 runtime library
      stat:
        path: /usr/lib/x86_64-linux-gnu/libjpeg.so.62
      register: libjpeg62_runtime

    - name: Check for libjpeg.so.8 compatibility shim
      stat:
        path: /usr/lib/x86_64-linux-gnu/libjpeg.so.8
      register: libjpeg8_runtime

    - name: Create compatibility symlink for libjpeg.so.8 if required
      file:
        src: /usr/lib/x86_64-linux-gnu/libjpeg.so.62
        dest: /usr/lib/x86_64-linux-gnu/libjpeg.so.8
        state: link
      become: true
      when:
        - libjpeg62_runtime.stat.exists
        - not libjpeg8_runtime.stat.exists

    - name: Check for libwebp.so.6 runtime library
      stat:
        path: /usr/lib/x86_64-linux-gnu/libwebp.so.6
      register: libwebp6_runtime

    - name: Check for libwebp.so.7 compatibility shim
      stat:
        path: /usr/lib/x86_64-linux-gnu/libwebp.so.7
      register: libwebp7_runtime

    - name: Create compatibility symlink for libwebp.so.7 if required
      file:
        src: /usr/lib/x86_64-linux-gnu/libwebp.so.6
        dest: /usr/lib/x86_64-linux-gnu/libwebp.so.7
        state: link
      become: true
      when:
        - libwebp6_runtime.stat.exists
        - not libwebp7_runtime.stat.exists
  when: tileserver_deploy_method == 'native'

- name: Install Docker engine (Debian/Ubuntu)
  apt:
    name:
      - docker.io
    state: present
    update_cache: yes
  when:
    - tileserver_deploy_method == 'docker'
    - ansible_pkg_mgr == 'apt'
  become: true

- name: Ensure Docker service is enabled and started
  systemd:
    name: docker
    enabled: yes
    state: started
  when: tileserver_deploy_method == 'docker'
  become: true

- name: Ensure tileserver user exists
  user:
    name: "{{ tileserver_user }}"
    system: yes
    create_home: no

- name: Create persistent MBTiles directory
  file:
    path: "{{ persistent_mbtiles_dir }}"
    state: directory
    owner: "{{ tileserver_user }}"
    group: "{{ tileserver_user }}"
    mode: '0755'

- name: Copy MBTiles from repository into persistent directory (if present)
  copy:
    src: "{{ item }}"
    dest: "{{ persistent_mbtiles_dir }}/"
    owner: "{{ tileserver_user }}"
    group: "{{ tileserver_user }}"
    mode: '0644'
  loop: "{{ mbtiles_files }}"
  when: item is file

- name: Create RAM disk mount point
  file:
    path: "{{ ramdisk_mount_point }}"
    state: directory
    owner: "{{ tileserver_user }}"
    group: "{{ tileserver_user }}"
    mode: '0755'

- name: Mount tmpfs for MBTiles (RAM disk)
  mount:
    path: "{{ ramdisk_mount_point }}"
    src: tmpfs
    fstype: tmpfs
    opts: "nodev,nosuid,size={{ ramdisk_size }}"
    state: mounted

- name: Rsync MBTiles from persistent storage to RAM disk
  command: "rsync -a {{ persistent_mbtiles_dir }}/ {{ ramdisk_mount_point }}/"
  args:
    creates: "{{ ramdisk_mount_point }}/"
  become: true
  notify: restart tileserver

- name: Ensure rsync will run on every boot (systemd service)
  copy:
    dest: /etc/systemd/system/tileserver-ram-sync.service
    content: |
      [Unit]
      Description=Sync MBTiles from disk to RAM disk for tileserver
      After=local-fs.target network.target mnt-tileserver\x2dmbtiles.mount

      [Service]
      Type=oneshot
      ExecStart=/usr/bin/rsync -a {{ persistent_mbtiles_dir }}/ {{ ramdisk_mount_point }}/
      RemainAfterExit=yes

      [Install]
      WantedBy=multi-user.target
  notify: restart tileserver

- name: Enable tileserver-ram-sync.service
  systemd:
    name: tileserver-ram-sync.service
    enabled: yes
    state: started
    daemon_reload: yes

- name: Install Node.js and npm (Debian/Ubuntu)
  block:
    - name: Check current Node.js version
      command: node --version
      register: node_version_check
      failed_when: false
      changed_when: false

    - name: Remove old Node.js versions
      apt:
        name:
          - nodejs
          - npm
        state: absent
        purge: yes
      when: node_version_check.rc != 0 or not node_version_check.stdout.startswith('v20.')

    - name: Install curl for NodeSource setup
      apt:
        name: curl
        state: present
      when: node_version_check.rc != 0 or not node_version_check.stdout.startswith('v20.')

    - name: Add NodeSource repository for Node.js 20.x
      shell: curl -fsSL https://deb.nodesource.com/setup_20.x | bash -
      args:
        creates: /etc/apt/sources.list.d/nodesource.list
      when: node_version_check.rc != 0 or not node_version_check.stdout.startswith('v20.')

    - name: Install Node.js 20.x
      apt:
        name: nodejs
        state: present
        update_cache: yes
      when: node_version_check.rc != 0 or not node_version_check.stdout.startswith('v20.')
        
    - name: Verify Node.js version
      command: node --version
      register: node_version
      changed_when: false
      
    - name: Assert Node.js version is at least 20
      assert:
        that:
          - "node_version.stdout is version('v20', '>=')"
        fail_msg: "Node.js version {{ node_version.stdout }} is too old. Need v20 or higher."
  when:
    - tileserver_deploy_method == 'native'
    - ansible_pkg_mgr == 'apt'

- name: Force cleanup of any existing tileserver-gl installations
  shell: |
    rm -rf /usr/lib/node_modules/tileserver-gl
    rm -rf /usr/lib/node_modules/.tileserver-gl-*
    rm -rf /usr/local/lib/node_modules/tileserver-gl
    rm -rf /usr/local/lib/node_modules/.tileserver-gl-*
    rm -f /usr/local/bin/tileserver-gl
    rm -f /usr/bin/tileserver-gl
  args:
    warn: false
  become: true
  failed_when: false
  when: tileserver_deploy_method == 'native'

- name: Install tileserver-gl globally via npm (with verbose output)
  shell: /usr/bin/npm install -g tileserver-gl --loglevel=info 2>&1
  environment:
    PATH: "/usr/bin:{{ ansible_env.PATH }}"
  become: true
  register: npm_install_result
  changed_when: "'added' in npm_install_result.stdout"
  when: tileserver_deploy_method == 'native'

- name: Show npm install output
  debug:
    var: npm_install_result.stdout_lines
  when:
    - tileserver_deploy_method == 'native'
    - npm_install_result.changed

- name: Deploy config.json-based styles (recommended approach)
  block:
    - name: Read config.json to extract styles configuration
      set_fact:
        config_json_content: "{{ lookup('file', playbook_dir + '/../' + config_json_path) | from_json }}"
      delegate_to: localhost
      run_once: true

    - name: Extract styles directory path from config.json
      set_fact:
        styles_directory: "{{ config_json_content.options.paths.styles }}"
        fonts_directory: "{{ config_json_content.options.paths.fonts }}"
        available_styles: "{{ config_json_content.styles.keys() | list }}"
      delegate_to: localhost
      run_once: true

    - name: Determine default style (last in config.json styles list)
      set_fact:
        default_style_name: "{{ available_styles[-1] }}"
        default_style_config: "{{ config_json_content.styles[available_styles[-1]] }}"
      delegate_to: localhost
      run_once: true

    - name: Display discovered configuration
      debug:
        msg:
          - "Styles directory: {{ styles_directory }}"
          - "Fonts directory: {{ fonts_directory }}"
          - "Available styles: {{ available_styles }}"
          - "Default style: {{ default_style_name }}"

    - name: Deploy config.json to target
      copy:
        src: "{{ playbook_dir }}/../{{ config_json_path }}"
        dest: "/var/lib/tileserver/{{ config_json_path }}"
        owner: "{{ tileserver_user }}"
        group: "{{ tileserver_user }}"
        mode: '0644'

    - name: Deploy styles directory to target
      synchronize:
        src: "{{ playbook_dir }}/../{{ styles_directory }}/"
        dest: "/var/lib/tileserver/{{ styles_directory }}/"
        delete: yes
        recursive: yes
      delegate_to: localhost

    - name: Deploy fonts directory to target
      synchronize:
        src: "{{ playbook_dir }}/../{{ fonts_directory }}/"
        dest: "/var/lib/tileserver/{{ fonts_directory }}/"
        delete: yes
        recursive: yes
      delegate_to: localhost

    - name: Set ownership for deployed directories
      file:
        path: "/var/lib/tileserver/{{ item }}"
        owner: "{{ tileserver_user }}"
        group: "{{ tileserver_user }}"
        recurse: yes
      loop:
        - "{{ styles_directory }}"
        - "{{ fonts_directory }}"

    - name: Check if web directory exists
      stat:
        path: "{{ playbook_dir }}/../web"
      register: web_directory_exists
      delegate_to: localhost

    - name: Deploy web directory for static assets (sprites, etc.)
      synchronize:
        src: "{{ playbook_dir }}/../web/"
        dest: "/var/lib/tileserver/web/"
        delete: yes
        recursive: yes
      delegate_to: localhost
      when: web_directory_exists.stat.exists | default(false)

    - name: Set ownership for web directory
      file:
        path: "/var/lib/tileserver/web"
        owner: "{{ tileserver_user }}"
        group: "{{ tileserver_user }}"
        recurse: yes
      when: web_directory_exists.stat.exists | default(false)
  when: use_config_json_styles | default(false)

- name: Handle Cloudflare tunnel configuration
  block:
    - name: Copy cloudflared ingress merge script to target (if updating existing tunnel)
      copy:
        src: "{{ playbook_dir }}/../scripts/merge_cloudflared_ingress.py"
        dest: "{{ cloudflared_merge_script_path }}"
        owner: root
        group: root
        mode: '0755'
      when: cloudflared_update_ingress

    - name: Install PyYAML package for merge script (Debian/Ubuntu)
      apt:
        name: python3-yaml
        state: present
      when: cloudflared_update_ingress and ansible_pkg_mgr == 'apt'

    - name: Merge ingress rule into existing cloudflared config on target
      command: >
        {{ cloudflared_merge_script_path }}
        --config {{ cloudflared_config_path }}
        {% if cloudflared_ingress_hostname != '' %} --hostname {{ cloudflared_ingress_hostname }} {% else %} --path '{{ cloudflared_ingress_path }}' {% endif %}
        --service '{{ cloudflared_ingress_service }}'
      register: merge_result
      changed_when: "'MODIFIED' in merge_result.stdout"
      failed_when: "merge_result.rc not in [0,3]"
      when: cloudflared_update_ingress

    - name: Restart cloudflared service if ingress modified
      systemd:
        name: "{{ cloudflared_service_name }}"
        state: restarted
        daemon_reload: yes
      when: cloudflared_update_ingress and (merge_result.stdout is defined and 'MODIFIED' in merge_result.stdout)
  when: use_config_json_styles | default(false)

- name: Install and configure a simple web server (nginx)
  block:
    - name: Install nginx
      apt:
        name: nginx
        state: present
      when: ansible_pkg_mgr == 'apt'

    - name: Deploy nginx site configuration for tileserver web
      template:
        src: nginx_tileserver.conf.j2
        dest: /etc/nginx/sites-available/tileserver.conf
        owner: root
        group: root
        mode: '0644'
      notify: restart nginx

    - name: Enable nginx site
      file:
        src: /etc/nginx/sites-available/tileserver.conf
        dest: /etc/nginx/sites-enabled/tileserver.conf
        state: link
      notify: restart nginx

    - name: Remove default nginx site if present
      file:
        path: /etc/nginx/sites-enabled/default
        state: absent
      notify: restart nginx

    - name: Ensure nginx is enabled and started
      systemd:
        name: nginx
        enabled: yes
        state: started
        daemon_reload: yes
  when: use_config_json_styles | default(false)

- name: Deploy tileserver systemd service
  template:
    src: tileserver-ram.service.j2
    dest: /etc/systemd/system/tileserver-ram.service
    owner: root
    group: root
    mode: '0644'
  notify: restart tileserver

- name: Enable and start tileserver service
  systemd:
    name: tileserver-ram.service
    enabled: yes
    state: started
    daemon_reload: yes

- name: Create systemd mount unit for RAM disk
  copy:
    dest: /etc/systemd/system/mnt-tileserver\x2dmbtiles.mount
    content: |
      [Unit]
      Description=RAM disk for tileserver MBTiles
      After=local-fs.target

      [Mount]
      What=tmpfs
      Where={{ ramdisk_mount_point }}
      Type=tmpfs
      Options=nodev,nosuid,size={{ ramdisk_size }}

      [Install]
      WantedBy=multi-user.target
  notify: restart tileserver

- name: Enable RAM disk mount
  systemd:
    name: mnt-tileserver\x2dmbtiles.mount
    enabled: yes
    state: started
    daemon_reload: yes
