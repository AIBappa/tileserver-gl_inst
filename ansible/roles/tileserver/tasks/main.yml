---
# Main tasks for tileserver role - implemented in later todos

- name: Extend sudo timeout to prevent password re-prompts
  lineinfile:
    path: /etc/sudoers.d/ansible-timeout
    line: 'Defaults timestamp_timeout=30'
    create: yes
    mode: '0440'
    validate: 'visudo -cf %s'

- name: Update apt cache (Debian/Ubuntu)
  apt:
    update_cache: yes
    cache_valid_time: 3600
  when: ansible_pkg_mgr == 'apt'

- name: Compute RAM disk size (1/3 of total RAM)
  shell: echo $(( $(free -m | awk 'NR==2{print $2}') / 3 ))
  register: ramdisk_calc
  changed_when: false

- name: Set ramdisk_size_mb fact
  set_fact:
    ramdisk_size_mb: "{{ ramdisk_calc.stdout | trim | int }}"

- name: Format ramdisk_size string (G or M)
  set_fact:
    ramdisk_size: "{{ ((ramdisk_size_mb | int) >= 1024) | ternary((((ramdisk_size_mb | int) // 1024) | int) ~ 'G', (ramdisk_size_mb | int) ~ 'M') }}"

- name: Validate tileserver deployment method
  assert:
    that:
      - tileserver_deploy_method in ['docker', 'native']
    fail_msg: "tileserver_deploy_method must be either 'docker' or 'native'"

- name: Install base runtime dependencies
  package:
    name:
      - rsync
      - python3
    state: present
  become: true

- name: Install native runtime libraries and shims
  block:
    - name: Install native runtime libraries
      package:
        name:
          - libjpeg62-turbo
          - libwebp6
        state: present
      become: true

    - name: Check for libjpeg.so.62 runtime library
      stat:
        path: /usr/lib/x86_64-linux-gnu/libjpeg.so.62
      register: libjpeg62_runtime

    - name: Check for libjpeg.so.8 compatibility shim
      stat:
        path: /usr/lib/x86_64-linux-gnu/libjpeg.so.8
      register: libjpeg8_runtime

    - name: Create compatibility symlink for libjpeg.so.8 if required
      file:
        src: /usr/lib/x86_64-linux-gnu/libjpeg.so.62
        dest: /usr/lib/x86_64-linux-gnu/libjpeg.so.8
        state: link
      become: true
      when:
        - libjpeg62_runtime.stat.exists
        - not libjpeg8_runtime.stat.exists

    - name: Check for libwebp.so.6 runtime library
      stat:
        path: /usr/lib/x86_64-linux-gnu/libwebp.so.6
      register: libwebp6_runtime

    - name: Check for libwebp.so.7 compatibility shim
      stat:
        path: /usr/lib/x86_64-linux-gnu/libwebp.so.7
      register: libwebp7_runtime

    - name: Create compatibility symlink for libwebp.so.7 if required
      file:
        src: /usr/lib/x86_64-linux-gnu/libwebp.so.6
        dest: /usr/lib/x86_64-linux-gnu/libwebp.so.7
        state: link
      become: true
      when:
        - libwebp6_runtime.stat.exists
        - not libwebp7_runtime.stat.exists
  when: tileserver_deploy_method == 'native'

- name: Install Docker engine (Debian/Ubuntu)
  apt:
    name:
      - docker.io
    state: present
    update_cache: yes
  when:
    - tileserver_deploy_method == 'docker'
    - ansible_pkg_mgr == 'apt'
  become: true

- name: Ensure Docker service is enabled and started
  systemd:
    name: docker
    enabled: yes
    state: started
  when: tileserver_deploy_method == 'docker'
  become: true

- name: Ensure tileserver user exists
  user:
    name: "{{ tileserver_user }}"
    system: yes
    create_home: no

- name: Create persistent MBTiles directory
  file:
    path: "{{ persistent_mbtiles_dir }}"
    state: directory
    owner: "{{ tileserver_user }}"
    group: "{{ tileserver_user }}"
    mode: '0755'

- name: Copy MBTiles from repository into persistent directory (if present)
  copy:
    src: "{{ item }}"
    dest: "{{ persistent_mbtiles_dir }}/"
    owner: "{{ tileserver_user }}"
    group: "{{ tileserver_user }}"
    mode: '0644'
  loop: "{{ mbtiles_files }}"
  when: item is file

- name: Create RAM disk mount point
  file:
    path: "{{ ramdisk_mount_point }}"
    state: directory
    owner: "{{ tileserver_user }}"
    group: "{{ tileserver_user }}"
    mode: '0755'

- name: Mount tmpfs for MBTiles (RAM disk)
  mount:
    path: "{{ ramdisk_mount_point }}"
    src: tmpfs
    fstype: tmpfs
    opts: "nodev,nosuid,size={{ ramdisk_size }}"
    state: mounted

- name: Rsync MBTiles from persistent storage to RAM disk
  command: "rsync -a {{ persistent_mbtiles_dir }}/ {{ ramdisk_mount_point }}/"
  args:
    creates: "{{ ramdisk_mount_point }}/"
  become: true
  notify: restart tileserver

- name: Ensure rsync will run on every boot (systemd service)
  copy:
    dest: /etc/systemd/system/tileserver-ram-sync.service
    content: |
      [Unit]
      Description=Sync MBTiles from disk to RAM disk for tileserver
      After=local-fs.target network.target mnt-tileserver\x2dmbtiles.mount

      [Service]
      Type=oneshot
      ExecStart=/usr/bin/rsync -a {{ persistent_mbtiles_dir }}/ {{ ramdisk_mount_point }}/
      RemainAfterExit=yes

      [Install]
      WantedBy=multi-user.target
  notify: restart tileserver

- name: Enable tileserver-ram-sync.service
  systemd:
    name: tileserver-ram-sync.service
    enabled: yes
    state: started
    daemon_reload: yes

- name: Install Node.js and npm (Debian/Ubuntu)
  block:
    - name: Check current Node.js version
      command: node --version
      register: node_version_check
      failed_when: false
      changed_when: false

    - name: Remove old Node.js versions
      apt:
        name:
          - nodejs
          - npm
        state: absent
        purge: yes
      when: node_version_check.rc != 0 or not node_version_check.stdout.startswith('v20.')

    - name: Install curl for NodeSource setup
      apt:
        name: curl
        state: present
      when: node_version_check.rc != 0 or not node_version_check.stdout.startswith('v20.')

    - name: Add NodeSource repository for Node.js 20.x
      shell: curl -fsSL https://deb.nodesource.com/setup_20.x | bash -
      args:
        creates: /etc/apt/sources.list.d/nodesource.list
      when: node_version_check.rc != 0 or not node_version_check.stdout.startswith('v20.')

    - name: Install Node.js 20.x
      apt:
        name: nodejs
        state: present
        update_cache: yes
      when: node_version_check.rc != 0 or not node_version_check.stdout.startswith('v20.')
        
    - name: Verify Node.js version
      command: node --version
      register: node_version
      changed_when: false
      
    - name: Assert Node.js version is at least 20
      assert:
        that:
          - "node_version.stdout is version('v20', '>=')"
        fail_msg: "Node.js version {{ node_version.stdout }} is too old. Need v20 or higher."
  when:
    - tileserver_deploy_method == 'native'
    - ansible_pkg_mgr == 'apt'

- name: Force cleanup of any existing tileserver-gl installations
  shell: |
    rm -rf /usr/lib/node_modules/tileserver-gl
    rm -rf /usr/lib/node_modules/.tileserver-gl-*
    rm -rf /usr/local/lib/node_modules/tileserver-gl
    rm -rf /usr/local/lib/node_modules/.tileserver-gl-*
    rm -f /usr/local/bin/tileserver-gl
    rm -f /usr/bin/tileserver-gl
  args:
    warn: false
  become: true
  failed_when: false
  when: tileserver_deploy_method == 'native'

- name: Install tileserver-gl globally via npm (with verbose output)
  shell: /usr/bin/npm install -g tileserver-gl --loglevel=info 2>&1
  environment:
    PATH: "/usr/bin:{{ ansible_env.PATH }}"
  become: true
  register: npm_install_result
  changed_when: "'added' in npm_install_result.stdout"
  when: tileserver_deploy_method == 'native'

- name: Show npm install output
  debug:
    var: npm_install_result.stdout_lines
  when:
    - tileserver_deploy_method == 'native'
    - npm_install_result.changed

- name: Prepare and generate local style on control (optional)
  block:
    - name: Ensure style rewrite is enabled
      assert:
        that: "style_rewrite_enabled"
        fail_msg: "Style rewrite is disabled (style_rewrite_enabled=false). Skipping generation."

    - name: Create mapping file on control for rewire script
      copy:
        content: "{{ style_source_mapping | to_nice_json }}"
        dest: "{{ playbook_dir }}/../scripts/style_mapping.json"
      delegate_to: localhost
      run_once: true

    - name: Run style rewriter on control to produce the local style
      command: >
        python3 {{ playbook_dir }}/../scripts/rewire_style.py
        --mapping-file {{ playbook_dir }}/../scripts/style_mapping.json
        --output {{ playbook_dir }}/../{{ style_output_path }}
        {% if cloudflared_tiles_base_url != '' %}--base-url '{{ cloudflared_tiles_base_url }}'{% else %}--port {{ tileserver_port }}{% endif %}
      delegate_to: localhost
      run_once: true

    - name: Ensure deploy directory exists on target
      file:
        path: "{{ style_deploy_dir }}/{{ style_deploy_subdir }}"
        state: directory
        owner: root
        group: root
        mode: '0755'

    - name: Copy generated style from control to target's web directory
      copy:
        src: "{{ playbook_dir }}/../{{ style_output_path }}"
        dest: "{{ style_deploy_dir }}/{{ style_deploy_subdir }}/{{ style_output_path | basename }}"
        owner: root
        group: root
        mode: '0644'
      when: style_rewrite_enabled

    - name: Derive Cloudflare public origin from tiles base URL
      when:
        - style_rewrite_enabled
        - cloudflared_tiles_base_url is defined
        - cloudflared_tiles_base_url | length > 0
      set_fact:
        cloudflared_tiles_base_origin: "{{ cloudflared_tiles_base_url | regex_replace('(/data.*)?$', '') }}"

    - name: Rewrite deployed style JSON to use cloudflared_tiles_base_url if configured
      when:
        - style_rewrite_enabled
        - cloudflared_tiles_base_url is defined
        - cloudflared_tiles_base_url | length > 0
      replace:
        path: "{{ style_deploy_dir }}/{{ style_deploy_subdir }}/{{ style_output_path | basename }}"
        regexp: "http://127\\.0\\.0\\.1(:[0-9]+)?"
        replace: "{{ cloudflared_tiles_base_origin }}"
      notify: restart nginx

    - name: Find any deployed JSON files under the web directory
      find:
        paths: "{{ style_deploy_dir }}"
        patterns: "*.json"
        recurse: yes
      register: deployed_json_files
      when:
        - style_rewrite_enabled
        - cloudflared_tiles_base_url is defined
        - cloudflared_tiles_base_url | length > 0

    - name: Replace localhost tile/sprite/glyph URLs in all deployed JSON files
      when:
        - deployed_json_files is defined
        - deployed_json_files.files | length > 0
      replace:
        path: "{{ item.path }}"
        regexp: "http://127\\.0\\.0\\.1(:[0-9]+)?"
        replace: "{{ cloudflared_tiles_base_origin }}"
      loop: "{{ deployed_json_files.files }}"
      notify: restart nginx

    - name: Check if maptiler-basic style is deployed
      stat:
        path: "{{ style_deploy_dir }}/maptiler-basic_local.json"
      register: maptiler_style_stat
      when: style_rewrite_enabled

    - name: Update maptiler-basic tile endpoint for Cloudflare hostname
      when:
        - style_rewrite_enabled
        - maptiler_style_stat.stat.exists | default(false)
        - cloudflared_tiles_base_origin is defined
      replace:
        path: "{{ style_deploy_dir }}/maptiler-basic_local.json"
        regexp: '"tiles": \[[^\]]+\]'
        replace: '"tiles": [\n        "{{ cloudflared_tiles_base_origin }}/data/v3/{z}/{x}/{y}.pbf"\n      ]'
      notify: restart nginx

    - name: Update maptiler-basic sprite endpoint for Cloudflare hostname
      when:
        - style_rewrite_enabled
        - maptiler_style_stat.stat.exists | default(false)
        - cloudflared_tiles_base_origin is defined
      replace:
        path: "{{ style_deploy_dir }}/maptiler-basic_local.json"
        regexp: '"sprite": "[^"]+"'
        replace: '"sprite": "{{ cloudflared_tiles_base_origin }}/maptiler-basic/sprite"'
      notify: restart nginx

    - name: Update maptiler-basic glyph endpoint for Cloudflare hostname
      when:
        - style_rewrite_enabled
        - maptiler_style_stat.stat.exists | default(false)
        - cloudflared_tiles_base_origin is defined
      replace:
        path: "{{ style_deploy_dir }}/maptiler-basic_local.json"
        regexp: '"glyphs": "[^"]+"'
        replace: '"glyphs": "{{ cloudflared_tiles_base_origin }}/fonts/{fontstack}/{range}.pbf"'
      notify: restart nginx

    - name: Copy example map.html to target web directory so it can reference the local style
      copy:
        src: "{{ playbook_dir }}/../web/map.html"
        dest: "{{ style_deploy_dir }}/map.html"
        owner: root
        group: root
        mode: '0644'
      when: style_rewrite_enabled

    - name: Copy cloudflared ingress merge script to target (if updating existing tunnel)
      copy:
        src: "{{ playbook_dir }}/../scripts/merge_cloudflared_ingress.py"
        dest: "{{ cloudflared_merge_script_path }}"
        owner: root
        group: root
        mode: '0755'
      when: cloudflared_update_ingress

    - name: Install PyYAML package for merge script (Debian/Ubuntu)
      apt:
        name: python3-yaml
        state: present
      when: cloudflared_update_ingress and ansible_pkg_mgr == 'apt'

    - name: Merge ingress rule into existing cloudflared config on target
      command: >
        {{ cloudflared_merge_script_path }}
        --config {{ cloudflared_config_path }}
        {% if cloudflared_ingress_hostname != '' %} --hostname {{ cloudflared_ingress_hostname }} {% else %} --path '{{ cloudflared_ingress_path }}' {% endif %}
        --service '{{ cloudflared_ingress_service }}'
      register: merge_result
      changed_when: "'MODIFIED' in merge_result.stdout"
      failed_when: "merge_result.rc not in [0,3]"
      when: cloudflared_update_ingress

    - name: Restart cloudflared service if ingress modified
      systemd:
        name: "{{ cloudflared_service_name }}"
        state: restarted
        daemon_reload: yes
      when: cloudflared_update_ingress and (merge_result.stdout is defined and 'MODIFIED' in merge_result.stdout)
  when: style_rewrite_enabled

- name: Install and configure a simple web server (nginx)
  block:
    - name: Install nginx
      apt:
        name: nginx
        state: present
      when: ansible_pkg_mgr == 'apt'

    - name: Deploy nginx site configuration for tileserver web
      template:
        src: nginx_tileserver.conf.j2
        dest: /etc/nginx/sites-available/tileserver.conf
        owner: root
        group: root
        mode: '0644'
      notify: restart nginx

    - name: Enable nginx site
      file:
        src: /etc/nginx/sites-available/tileserver.conf
        dest: /etc/nginx/sites-enabled/tileserver.conf
        state: link
      notify: restart nginx

    - name: Remove default nginx site if present
      file:
        path: /etc/nginx/sites-enabled/default
        state: absent
      notify: restart nginx

    - name: Ensure nginx is enabled and started
      systemd:
        name: nginx
        enabled: yes
        state: started
        daemon_reload: yes
  when: style_rewrite_enabled

- name: Deploy tileserver systemd service
  template:
    src: tileserver-ram.service.j2
    dest: /etc/systemd/system/tileserver-ram.service
    owner: root
    group: root
    mode: '0644'
  notify: restart tileserver

- name: Enable and start tileserver service
  systemd:
    name: tileserver-ram.service
    enabled: yes
    state: started
    daemon_reload: yes

- name: Create systemd mount unit for RAM disk
  copy:
    dest: /etc/systemd/system/mnt-tileserver\x2dmbtiles.mount
    content: |
      [Unit]
      Description=RAM disk for tileserver MBTiles
      After=local-fs.target

      [Mount]
      What=tmpfs
      Where={{ ramdisk_mount_point }}
      Type=tmpfs
      Options=nodev,nosuid,size={{ ramdisk_size }}

      [Install]
      WantedBy=multi-user.target
  notify: restart tileserver

- name: Enable RAM disk mount
  systemd:
    name: mnt-tileserver\x2dmbtiles.mount
    enabled: yes
    state: started
    daemon_reload: yes
